<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organigrama RCM</title>
    
    <!-- FAVICONS -->
    <link rel="apple-touch-icon" sizes="57x57" href="assets/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="assets/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="assets/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="assets/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="assets/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="assets/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="assets/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="assets/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="assets/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="assets/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="assets/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png">
    <link rel="manifest" href="assets/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="assets/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H3DNJQGN34"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-H3DNJQGN34');
    </script>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* --- SWISS DESIGN VARIABLES --- */
        :root {
            --bg-color: #F4F4F4; /* Light Grey Background */
            --node-bg: #FFFFFF;
            --text-primary: #1A1A1A;
            --text-secondary: #757575;
            --accent-color: #278b65; /* Swiss Red */
            --line-color: #C0C0C0;
            --font-stack: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            font-family: var(--font-stack);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        /* --- BLURRED HEADER CARD --- */
        header {
            position: fixed; /* Fixes it to the screen */
            top: 24px;
            left: 24px;
            width: 380px; /* Slightly wider to fit logo */
            padding: 20px;
            z-index: 100;
            
            /* Glassmorphism Effect */
            background-color: rgba(244, 244, 244, 0.75); 
            backdrop-filter: blur(4px); 
            -webkit-backdrop-filter: blur(4px); 
            
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            pointer-events: none;
            
            /* Flexbox Layout for Logo + Text */
            display: flex;
            align-items: center;
            gap: 16px; 
        }

        /* Logo container */
        .header-logo {
            width: 60px; /* Adjust based on your logo shape */
            height: 60px;
            flex-shrink: 0; /* Prevent logo from squishing */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Text container */
        .header-text {
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-size: 18px;
            font-weight: 700;
            margin: 0 0 4px 0;
            color: var(--text-primary);
            letter-spacing: -0.01em;
            line-height: 1.2;
        }

        h2 {
            font-size: 13px;
            font-weight: 400;
            margin: 0;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* --- CHART STYLES --- */
        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        svg:active {
            cursor: grabbing;
        }

        /* The Node Container */
        .node rect {
            fill: var(--node-bg);
            stroke: var(--line-color);
            stroke-width: 1px;
            transition: stroke 0.2s ease, filter 0.2s ease;
        }

        .node:hover rect {
            stroke: var(--text-primary);
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.08));
        }

        /* HTML Content inside Node (ForeignObject) */
        .node-content-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Vertically center */
            padding: 0 16px; /* Horizontal padding */
            box-sizing: border-box;
            pointer-events: none; /* Let clicks pass through to the rect */
        }

        .node-role {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.25;
            margin-bottom: 2px;
            
            /* Text Wrapping Logic */
            white-space: normal; 
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3; /* Limit to 3 lines */
            -webkit-box-orient: vertical;
        }

        .node-person {
            font-size: 11px;
            font-weight: 400;
            color: var(--text-secondary);
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Expand/Collapse Button */
        .node-circle {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .node-circle:hover {
            transform: scale(1.2);
        }

        .link {
            fill: none;
            stroke: var(--line-color);
            stroke-width: 1.5px;
        }

        /* --- UTILS --- */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: var(--text-secondary);
        }

        #error-msg {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-left: 4px solid var(--accent-color);
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            max-width: 400px;
        }
    </style>
</head>
<body>

    <header>
        <div class="header-logo">
            <!-- Ensure this path is correct relative to the HTML file -->
            <img src="assets/logos/RCM-UPR-logo.svg" alt="RCM Logo">
        </div>
        <div class="header-text">
            <h1>Recinto de Ciencias Médicas</h1>
            <h2>Estructura Organizacional Académica y Administrativa</h2>
        </div>
    </header>

    <div id="loading">Cargando visualización...</div>
    
    <div id="error-msg">
        <h3>Error de conexión</h3>
        <p>No se pudo cargar 'organigrama.json'.</p>
        <p style="font-size: 12px; color: #666;">Asegúrese de ejecutar este archivo usando un servidor local (ej. Live Server en VS Code o Python http.server) debido a las políticas de seguridad del navegador.</p>
    </div>

    <div id="chart"></div>

    <script>
        // --- CONFIGURATION ---
        const width = window.innerWidth;
        const height = window.innerHeight;
        const duration = 600; 
        
        // Increased sizes for text wrapping
        const nodeWidth = 240; 
        const nodeHeight = 85; 
        
        // --- SVG SETUP ---
        const svg = d3.select("#chart").append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(d3.zoom().scaleExtent([0.1, 2]).on("zoom", (event) => {
                g.attr("transform", event.transform);
            }))
            .append("g")
            .attr("transform", "translate(150, " + (height / 2) + ")"); // Start slightly right

        const g = svg.append("g");

        // --- TREE LAYOUT ---
        const treeMap = d3.tree().nodeSize([nodeHeight + 30, nodeWidth + 80]);

        let i = 0;
        let root;

        // --- LOAD DATA ---
        d3.json("organigrama.json")
            .then(data => {
                document.getElementById('loading').style.display = 'none';

                const rawRoot = data.organization.structure.rectoria;
                const processedData = formatData(rawRoot);

                root = d3.hierarchy(processedData, d => d.children);
                root.x0 = height / 2;
                root.y0 = 0;

                // Handle initial collapsed state from JSON
                root.descendants().forEach(d => {
                    if (d.data.initial_collapsed && d.children) {
                        d._children = d.children;
                        d.children = null;
                    }
                });

                update(root);
            })
            .catch(error => {
                console.error(error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-msg').style.display = 'block';
            });

        function formatData(node) {
            let newNode = { ...node };
            if (newNode.sub_elements) {
                newNode.children = newNode.sub_elements.map(formatData);
                delete newNode.sub_elements;
            }
            return newNode;
        }

        // --- RENDER FUNCTION ---
        function update(source) {
            const treeData = treeMap(root);

            // Compute the new tree layout
            const nodes = treeData.descendants();
            const links = treeData.links();

            // Fixed-depth positioning (Horizontal)
            nodes.forEach(d => { d.y = d.depth * 320; });

            // ****************** Nodes ******************
            const node = g.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));

            // Enter new nodes at the parent's previous position
            const nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr("transform", d => "translate(" + source.y0 + "," + source.x0 + ")")
                .on('click', click);

            // 1. Rectangle Background
            nodeEnter.append('rect')
                .attr('width', nodeWidth)
                .attr('height', nodeHeight)
                .attr('x', 0)
                .attr('y', -nodeHeight / 2)
                .attr('rx', 6) // Slightly more rounded
                .attr('ry', 6);

            // 2. ForeignObject for HTML Content (Text Wrapping)
            nodeEnter.append('foreignObject')
                .attr('width', nodeWidth)
                .attr('height', nodeHeight)
                .attr('x', 0)
                .attr('y', -nodeHeight / 2)
                .append('xhtml:div')
                .attr('class', 'node-content-wrapper')
                .html(d => {
                    const role = d.data.name;
                    const person = d.data.head ? d.data.head : "";
                    
                    // Conditionally render person only if exists
                    let html = `<div class="node-role">${role}</div>`;
                    if (person) {
                        html += `<div class="node-person">${person}</div>`;
                    }
                    return html;
                });

            // 3. Circle Button (Expand/Collapse)
            nodeEnter.append('circle')
                .attr('class', 'node-circle')
                .attr('r', 7)
                .attr('cx', nodeWidth)
                .attr('cy', 0)
                .style("opacity", d => (d._children || d.children) ? 1 : 0);

            // UPDATE
            const nodeUpdate = node.merge(nodeEnter);

            // Transition to the new position
            nodeUpdate.transition()
                .duration(duration)
                .attr("transform", d => "translate(" + d.y + "," + d.x + ")");

            // Style updates based on state
            nodeUpdate.select('rect')
                .style("fill", "#FFF")
                .style("stroke", d => d._children ? "#999" : "#E0E0E0");

            nodeUpdate.select('circle.node-circle')
                .style("fill", d => d._children ? "#ff6400" : "#FFF") // Red if closed
                .style("stroke", d => d._children ? "#ff6400" : "#999")
                .style("opacity", d => (d._children || d.children) ? 1 : 0);

            // EXIT
            const nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", d => "translate(" + source.y + "," + source.x + ")")
                .remove();

            nodeExit.select('rect').attr('fill-opacity', 0);
            nodeExit.select('foreignObject').style('opacity', 0);
            nodeExit.select('circle').attr('opacity', 0);

            // ****************** Links ******************
            const link = g.selectAll('path.link')
                .data(links, d => d.target.id);

            const linkEnter = link.enter().insert('path', "g")
                .attr("class", "link")
                .attr('d', d => {
                    const o = { x: source.x0, y: source.y0 };
                    return diagonal(o, o);
                });

            const linkUpdate = link.merge(linkEnter);

            linkUpdate.transition()
                .duration(duration)
                .attr('d', d => diagonal(d.source, d.target));

            link.exit().transition()
                .duration(duration)
                .attr('d', d => {
                    const o = { x: source.x, y: source.y };
                    return diagonal(o, o);
                })
                .remove();

            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            function diagonal(s, d) {
                const sourceX = s.y + nodeWidth;
                const sourceY = s.x;
                const targetX = d.y;
                const targetY = d.x;

                return `M ${sourceX} ${sourceY}
                        C ${(sourceX + targetX) / 2} ${sourceY},
                          ${(sourceX + targetX) / 2} ${targetY},
                          ${targetX} ${targetY}`;
            }

            function click(event, d) {
                // If the node has children (collapsed or expanded)
                if (d.children || d._children) {
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                        d._children = null;
                    }
                    update(d);
                }
            }
        }
    </script>
</body>
</html>